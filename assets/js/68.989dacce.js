(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{491:function(t,a,r){"use strict";r.r(a);var s=r(42),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"rocketmq-基本概念-返回"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq-基本概念-返回"}},[t._v("#")]),t._v(" RocketMQ 基本概念 "),r("RouterLink",{attrs:{to:"/",title:"首页"}},[t._v("返回")])],1),t._v(" "),r("h2",{attrs:{id:"生产者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生产者"}},[t._v("#")]),t._v(" 生产者")]),t._v(" "),r("p",[t._v("生产者发送业务系统产生的消息给broker。RocketMQ提供了多种发送方式：同步的、异步的、单向的。")]),t._v(" "),r("h3",{attrs:{id:"生产者组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生产者组"}},[t._v("#")]),t._v(" 生产者组")]),t._v(" "),r("p",[t._v("具有相同角色的生产者被分到一组。假如原始的生产者在事务后崩溃，broker会联系\n同一生产者组中的不同生产者实例，继续提交或回滚事务。")]),t._v(" "),r("h2",{attrs:{id:"消费者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者"}},[t._v("#")]),t._v(" 消费者")]),t._v(" "),r("p",[t._v("一个消费者从broker拉取信息，并将信息返还给应用。为了我们应用的正确性，提供了两种消费者类型：")]),t._v(" "),r("h3",{attrs:{id:"拉式消费者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拉式消费者"}},[t._v("#")]),t._v(" 拉式消费者")]),t._v(" "),r("p",[t._v("拉式消费者从broker拉取消息，一旦一批消息被拉取，用户应用系统将发起消费过程。")]),t._v(" "),r("h3",{attrs:{id:"推式消费者"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#推式消费者"}},[t._v("#")]),t._v(" 推式消费者")]),t._v(" "),r("p",[t._v("推式消费者，从另一方面讲，囊括了消息的拉取、消费过程，并保持了内部的其他工作，留下了一个回调\n接口给终端用户去实现，实现在消息到达时要执行的内容。")]),t._v(" "),r("h3",{attrs:{id:"消费者组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者组"}},[t._v("#")]),t._v(" 消费者组")]),t._v(" "),r("p",[t._v("具有相同角色的消费者被组在一起，称为消费者组。它是一个伟大的概念，它完成了负载均衡和容错的目标。\n就消费消息而言，它是非常容易的。")]),t._v(" "),r("p",[t._v("一个消费组中的消费者实例必须有确定的相同的订阅topic。")]),t._v(" "),r("h2",{attrs:{id:"topic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" Topic")]),t._v(" "),r("p",[t._v("Topic是一个消息的目录，在这个目录中，生产者传送消息，消费者拉取消息。Topic与生产者和消费者之间的关系非常的宽松。\n明确的，一个Topic可以有0个，1个或多个生产者向它发送消息。相反的，一个生产者可以发送不同Topic的消息。\n在消费者方面，一个Topic可以被0个，1个或多个消费者组订阅。相似的，一个消费者组可以订阅1个或多个Topic，只要组内的消费者实例\n保持订阅的一致性。")]),t._v(" "),r("h2",{attrs:{id:"message-消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#message-消息"}},[t._v("#")]),t._v(" Message（消息）")]),t._v(" "),r("p",[t._v("消息是被传递的信息。一个消息必须有一个Topic，它可以理解为信件上的地址。一个消息也可以有一个可选的tag，和额外的key-value对。\n例如：你可以设置业务中的键到你的消息中，在broker服务中查找消息，以便在开发期间诊断问题。")]),t._v(" "),r("h2",{attrs:{id:"消息队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),r("p",[t._v("Topic被分割成一个或多个消息队列。队列分为3中角色：异步主、同步主、从。如果你不能容忍消息丢失，我们建议你部署同步主，并加一个从队列。\n如果你容忍丢失，但你希望队列总是可用，你可以部署异步主和从队列。如果你想最简单，你只需要一个异步主，不需要从队列。\n消息保存磁盘的方式也有两种，推荐使用的是异步保存，同步保存是昂贵的并会导致性能损失，如果你想要可靠性，我们推荐你使用同步主+从的方式。")]),t._v(" "),r("h2",{attrs:{id:"tag-标签"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tag-标签"}},[t._v("#")]),t._v(" Tag（标签）")]),t._v(" "),r("p",[t._v("标签，用另外一个词来说，就是子主题，为用户提供额外的灵活性。具有相同Topic的消息可以有不同的tag。")]),t._v(" "),r("h2",{attrs:{id:"broker-队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#broker-队列"}},[t._v("#")]),t._v(" Broker（队列）")]),t._v(" "),r("p",[t._v("Broker是RocketMQ的一个主要组件，它接收生产者发送的消息，存储它们并准备处理消费者的拉取请求。它也存储消息相关的元数据，\n包括消费组，消费成功的偏移量，主题、队列的信息。")]),t._v(" "),r("h2",{attrs:{id:"名称服务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#名称服务"}},[t._v("#")]),t._v(" 名称服务")]),t._v(" "),r("p",[t._v("名称服务主要提供路由信息。生产者/消费者客户端寻找topic，并找到通信的队列列表。")]),t._v(" "),r("h2",{attrs:{id:"消息顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息顺序"}},[t._v("#")]),t._v(" 消息顺序")]),t._v(" "),r("p",[t._v("当"),r("code",[t._v("DefaultMQPushConsumer")]),t._v("被使用，你就要决定消费消息时，是顺序消费还是同时消费。")]),t._v(" "),r("ul",[r("li",[t._v("顺序消费")])]),t._v(" "),r("p",[t._v("顺序消费消息的意思是 消息将按照生产者发送到队列时的顺序被消费掉。如果你被强制要求使用全局的顺序，你要确保你的topic只有一个消息队列。")]),t._v(" "),r("p",[t._v("如果指定顺序消费，消息被同时消费的数量就是订阅这个topic的消费组的数量。")]),t._v(" "),r("ul",[r("li",[t._v("同时消费")])]),t._v(" "),r("p",[t._v("当同时消费消息时，消息同时消费的最大数量取决于消费客户端指定的线程池的大小。")])])}),[],!1,null,null,null);a.default=e.exports}}]);